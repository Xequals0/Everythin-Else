# CS419 Computer Security: Assignment 4
# Professor Krzyzanowski Spring 2018
# Anirudh Tunoori netid: at813
# Yaowen Zhang netid: yz579

# This is the submission textfile that contains the explanations for each of the exploits. Please see the screenshots (found in the same folder) of the final output and critical intermediate steps for each of these exploits along with our input shell script.

# Stack1
This exploit is fairly straightforward. We want to change the value of “modified” so that the if statement if(modified == 0x61626364) evaluates to true. “0x61626364” is actually the hex/ascii representation of abcd. This machine is little endian so in order to set modified to ‘abcd’ we actually want to have ‘dcba’ in our final (concatenated) input. The code indicates that “modified” is located above (before) the buffer in the stack such that overflowing the buffer will allow us to change the value held by “modified”. The buffer was declared/intended to hold 64 bytes (and since a char is one byte); we decided to pass 64 characters (A’s) followed by (concatenated with) ’dcba’. This input was successful; no additional offset/padding beyond the 64 characters was necessary. (Please see the enclosed screenshot for stack1).

____________________________________________________________________________
# Stack4
In this exploit, we want to call the win() function which can be done by redirecting the EIP to the address of the win() function. This necessitates us finding thquitque address of win() the location of the buffer (the address at which the buffer begins) and the location of the return address. The difference of these addresses can help us determine the number of bytes of offset/paddding we need in order to overflow the buffer sufficiently enough to reach the EIP. First we rand gdb on stack4 and and used the disassemble command on win in order to find the address of this function: 0x080483f4. This machine is little endian so we want the address to be formatted as ‘\xf4\x83\x04\x08’. We then disassembled main(). We set a breakpoint at the starting address of main() and called run. Using the information registers command helped us find the return address for this function; which is held by ESP (stack frame pointer): 0xbffffd2c (at this moment nothing else in the function has started). We set a breakpoint at 0x08048418 where gets is called and called info register after continuing. This time the ESP (which points to the top of the stack) should be pointing to the location of the buffer: 0xbffffceo. Now, we found the difference in the two addresses: 76. Using the information obtained thus far, we were able to successfully craft our final input: 76 A’s concatenated with (followed by) the address of win(): ‘\xf4\x83\x04\x08’.(Please see the enclosed screenshots for stack4).

____________________________________________________________________________
# Format0
In this exploit, we are trying to set the variable “target”, which is set to 0, to “0xdeadbeef”. An examination of the code shows us that the variable “target” is found immediately above (before) the buffer on the stack such that overflowing the buffer allows us to reach the location of “target”. The buffer holds 64 bytes (and since a char is one byte); our desired inout will need at least 64 characters (A’s). The sprintf() function does not stop until it reads the null-terminating byte. Furthermore, our machine is little endian so the value we want to supply to “target” is “\xef\xbe\xad\xde”. Finally, we are asked to craft our exploit in less than 10 bytes of input. We can use “%x” (a formatting directive associated with the printf family of functions) in order to format our string with the required number of characters. This will help keep us within the 10 byte limit. (Please see the enclosed screenshot for format0).

____________________________________________________________________________
# Heap0
In this exploit, we want to redirect the EIP to the address of the winner() function. To do so we need to find the address of the winner() function and determine the number of bytes we need to overflow the buffer with in order to reach the function pointer fp. We ran gdb on heap0 and provided it with some input (A’s) in order to find the address of the buffer (where it begins) and the address of fp. We found that the buffer (data) is at 0x804a008 and the fp is at 0x804a050. Subtracting the difference gives us the necessary offset: 72 bytes. We used the gdb print command to find the locations of the functions. winner() is located at: 0x8048464. As this machine is little endian we want: “\x64\x84\x04\x08”. Thus, we can craft our final input with 72 A’s and concatenate it with ‘\x64\x84\x04\x08’. (Please see the enclosed screenshot for heap0).
